using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Stella.MinimalApi.SourceGenerator;

[Generator]
public sealed class EndpointDiscoveryGenerator : IIncrementalGenerator
{
    private const string AttributeName =
        "Stella.MinimalApi.EndpointDiscoveryAttribute";

    private const string DiscoveryInterface =
        "Stella.MinimalApi.IEndpointDiscovery";

    private const string EndpointInterface =
        "Stella.MinimalApi.IEndpoint";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var discoveries =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                AttributeName,
                static (node, _) => node is ClassDeclarationSyntax,
                static (ctx, _) => (INamedTypeSymbol)ctx.TargetSymbol);

        var combined =
            context.CompilationProvider.Combine(discoveries.Collect());

        context.RegisterSourceOutput(
            combined,
            static (spc, source) =>
            {
                var (compilation, discoveryTypes) = source;

                foreach (var discovery in discoveryTypes)
                {
                    if (!IsValidDiscovery(discovery))
                        continue;

                    // 🔑 CRITICAL GUARD:
                    // Do NOT generate unless the partial method exists
                    if (!HasEndpointDiscoveryAttribute(discovery))
                        continue;

                    Generate(spc, compilation, discovery);
                }
            });
    }

    private static bool IsValidDiscovery(INamedTypeSymbol symbol)
    {
        if (!symbol.IsPartial())
            return false;

        return symbol.AllInterfaces.Any(i =>
            i.ToDisplayString() == DiscoveryInterface);
    }

    private static bool HasEndpointDiscoveryAttribute(INamedTypeSymbol symbol)
    {
        foreach (var attribute in symbol.GetAttributes())
        {
            var attrClass = attribute.AttributeClass;
            if (attrClass is null)
                continue;

            if (attrClass.Name == "EndpointDiscoveryAttribute" &&
                attrClass.ContainingNamespace.ToDisplayString() == "Stella.MinimalApi")
            {
                return true;
            }
        }

        return false;
    }


    private static void Generate(
        SourceProductionContext context,
        Compilation compilation,
        INamedTypeSymbol discovery)
    {
        var endpoints = compilation.Assembly
            .GlobalNamespace
            .GetAllTypes()
            .Where(t =>
                t is { TypeKind: TypeKind.Class, IsAbstract: false } &&
                t.AllInterfaces.Any(i =>
                    i.ToDisplayString() == EndpointInterface))
            .OrderBy(t => t.ToDisplayString())
            .ToArray();

        if (endpoints.Length == 0)
            return;

        var ns = discovery.ContainingNamespace.IsGlobalNamespace
            ? null
            : discovery.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Stella.MinimalApi;");

        if (ns is not null)
        {
            sb.AppendLine($"namespace {ns};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {discovery.Name}");
        sb.AppendLine("{");
        sb.AppendLine("    private partial void RegisterGenerated(IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var endpoint in endpoints)
        {
            sb.AppendLine(
                $"        services.AddSingleton<IEndpoint, {endpoint.ToDisplayString()}>();");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource(
            $"{discovery.Name}.Endpoints.g.cs",
            sb.ToString());
    }
}
